# Week 2 - EPIC 2: Contract Management

## Session 6 (2026-02-16) - Contract Model + API (Backend)

**Focus**: ForeignKey relationships, nested API routes, cross-field validation

**What I built:**
- Contract model with ForeignKey to Employee (1:N relationship)
- TextChoices for contract_type (determinato, indeterminato, stagista) and CCNL
- DecimalField for RAL (exact-precision currency)
- Nullable end_date (NULL = active contract)
- ContractSerializer with cross-field validation (end_date > start_date)
- ContractViewSet with nested URL routes (/api/employees/{id}/contracts/)
- 9 API tests (22 total backend)

**What I learned:**
- ForeignKey = SQL FOREIGN KEY REFERENCES, but with `related_name` for reverse access
- `employee.contracts.all()` replaces explicit JOINs (Django ORM magic via related_name)
- `on_delete=CASCADE`: what happens when parent is deleted (CASCADE, SET_NULL, PROTECT)
- NULL vs sentinel (9999-12-31) for "no end date": app DBs use NULL, DWH uses sentinels (SCD Type 2)
- `null=True` + `blank=True` needed together for optional non-string fields (DB layer + validation layer)
- `DateField` for dates (no time component) vs `DateTimeField` for timestamps
- `DecimalField` maps to PostgreSQL `NUMERIC` — exact arithmetic, no floating-point errors
- `validate()` (no field name): cross-field validation with access to all parsed fields
- `validate_<field>()`: single-field validation only
- `data.get()` in validate(): safe access for PATCH requests where not all fields are sent
- Nested ViewSet pattern: `get_queryset` filters by URL param, `perform_create` injects parent
- `get_object_or_404`: shortcut that returns 404 if parent doesn't exist
- `.as_view({"get": "list", "post": "create"})`: manual HTTP method → ViewSet action mapping
- `<int:employee_pk>` in URL → `self.kwargs["employee_pk"]` in view (like SP parameter from URL)
- Django auto-creates INDEX on FK columns (unlike SQL Server)
- `sqlmigrate` command: shows actual SQL generated by a migration
- Model class names: singular in Django (Contract, not Contracts)

**Key pattern: SQL → Django ORM mapping (new concepts):**
| SQL Server | Django ORM |
|---|---|
| `FOREIGN KEY REFERENCES Employees(id)` | `models.ForeignKey(Employee, on_delete=CASCADE)` |
| `JOIN Contracts ON emp.id = c.employee_id` | `employee.contracts.all()` via related_name |
| `ON DELETE CASCADE` | `on_delete=models.CASCADE` |
| `NUMERIC(10,2)` | `DecimalField(max_digits=10, decimal_places=2)` |
| `DATE NULL` | `DateField(null=True, blank=True)` |
| `CHECK (end_date > start_date)` | `validate(self, data)` cross-field validation |
| `WHERE employee_id = @param` (in SP) | `self.kwargs["employee_pk"]` (from URL) |
| `CREATE INDEX ON (employee_id)` | Automatic on ForeignKey fields |

**Architecture pattern: nested API routes:**
| HTTP | URL | ViewSet Action | SQL Equivalent |
|---|---|---|---|
| GET | /api/employees/{id}/contracts/ | list | SELECT * WHERE employee_id = @id |
| POST | /api/employees/{id}/contracts/ | create | INSERT INTO ... (employee_id = @id) |
| GET | /api/employees/{id}/contracts/{pk}/ | retrieve | SELECT * WHERE id = @pk |
| PATCH | /api/employees/{id}/contracts/{pk}/ | partial_update | UPDATE SET ... WHERE id = @pk |
| DELETE | /api/employees/{id}/contracts/{pk}/ | destroy | DELETE WHERE id = @pk |

**Next steps:**
- [x] EPIC 2 Frontend: Contract list + create/edit forms — done in Session 7
- [ ] EPIC 2 Phase 2: File upload (PDF) + S3 storage

---

## Session 7 (2026-02-18) - Contract CRUD Frontend

**Focus**: Vue components for nested resources, route params, form validation alignment

**What I built:**
- api.js: 5 contract API functions (fetchContract, fetchContracts, createContract, updateContract, deleteContract) with guard clauses
- ContractList.vue: table with Promise.all parallel fetch, active/closed badges, RAL currency formatting, delete flow with ConfirmDialog
- ContractForm.vue: dual-mode create/edit, dropdown choices matching backend TextChoices, optional end_date with payload cleanup
- 3 View wrappers (ContractListView, ContractCreateView, ContractEditView)
- Vue Router: 3 nested routes with :employeeId and :contractId params
- EmployeeList.vue: "Contratti" link per employee row
- 22 new frontend tests (12 ContractList + 10 ContractForm)

**What I learned:**
- Promise.all: fetch multiple APIs in parallel (like running two SQL queries simultaneously)
- Intl.NumberFormat('it-IT'): browser-native currency formatting (no external library needed)
- Derived state: active/closed badge from `end_date === null` (no redundant DB column)
- Route params are STRINGS: must convert with `Number()` before passing as typed Number prop
- `<input type="number">` + v-model: Vue auto-converts to Number (not String) — caught by failing tests
- Frontend/backend choices MUST match: `<select>` options must be identical to Django TextChoices values — "stage" ≠ "stagista" causes 400 error
- Optional field UX: remove both HTML `required` attribute AND asterisk from label
- Payload cleanup before API call: empty string '' should be removed (delete), not sent as '' (which != null)
- Hard delete messaging: "irreversibile" (vs "reversibile" for soft delete)
- Guard clauses (fail-fast): `if (!employeeId) throw new Error(...)` prevents silent bugs with `undefined` in URL

**Key pattern: EmployeeForm → ContractForm differences:**
| Aspect | EmployeeForm | ContractForm |
|---|---|---|
| Props | employee (Object/null) | employeeId (Number) + contract (Object/null) |
| Immutable field | email (disabled in edit) | None |
| API call | createEmployee(payload) | createContract(employeeId, payload) |
| Optional field | department (string, blank ok) | end_date (date, needs '' → delete cleanup) |
| Cancel link | / (employee list) | /employees/{id}/contracts (contract list) |
| Choices | 1 select (role) | 2 selects (contract_type, ccnl) |

**Mistakes caught in code review:**
1. `result` not declared with `let` (strict mode ReferenceError)
2. Select options didn't match backend TextChoices ("stage" vs "stagista")
3. end_date marked as required (should be optional for active contracts)
4. end_date '' cleanup only in edit branch (needed in both)
5. "Annulla" link pointed to / instead of contracts list
6. `_nonFieldErrors` key didn't match template's `non_field_errors`
7. Unused imports and refs (onMounted, useRoute, fetchEmployee, employee, loading, error)

**Next steps:**
- [x] EPIC 2 Phase 2: File upload (PDF) — done in Session 8
- [ ] EPIC 3: Onboarding automation

---

## Session 8 (2026-02-19) - PDF Upload for Contracts (EPIC 2 Phase 2)

**Focus**: File upload, multipart/form-data, Django FileField, FormData API

**What I built:**
- Django settings: MEDIA_ROOT, MEDIA_URL, media URL serving (if DEBUG)
- Contract model: FileField(upload_to='contracts/%Y/%m/') + migration 0003
- ContractSerializer: SerializerMethodField for document_url, validate_document() (ext + content-type + size)
- api.js: FormData support — buildContractBody helper, auto-detect FormData in apiRequest to skip Content-Type
- ContractForm.vue: file input with client-side PDF/size validation, existing document link in edit mode
- ContractList.vue: "PDF" column with Visualizza link or dash
- 15 new tests (7 backend + 8 frontend), total 78

**What I learned:**
- FileField stores only the PATH in DB (VARCHAR), the actual file lives on disk — not a BLOB
- MEDIA_ROOT = physical directory on disk, MEDIA_URL = HTTP URL prefix (like alias in web server)
- upload_to='contracts/%Y/%m/' creates date-based subdirectories automatically (like partitioning)
- multipart/form-data: binary data can't go in JSON, needs a different encoding with boundaries
- FormData: browser API that builds multipart body — NEVER set Content-Type manually (browser adds boundary)
- SerializerMethodField: read-only computed column — uses request.build_absolute_uri() for absolute URLs
- File validation cascade: extension → content-type → size (defense in depth, like layered security)
- Client-side validation mirrors server validation: fail-fast UX, prevents unnecessary roundtrips
- SimpleUploadedFile: Django test utility for creating fake uploaded files with specific content-type
- override_settings(MEDIA_ROOT=tempdir): test isolation — don't pollute real media directory
- `if settings.DEBUG: urlpatterns +=`: media serving only in dev (Nginx/S3 in production)

**Key pattern: JSON vs FormData in api.js:**
```
Senza file:  JSON.stringify(payload) → Content-Type: application/json
Con file:    FormData(payload + file) → Content-Type: multipart/form-data (auto)
```

**Key pattern: document vs document_url:**
| Campo | Direzione | Tipo | Scopo |
|---|---|---|---|
| document | Frontend → Backend | FileField (write) | Riceve il file nell'upload |
| document_url | Backend → Frontend | SerializerMethodField (read) | URL assoluto per preview/download |

**Architecture: file storage flow:**
```
Browser → multipart POST → DRF parser → FileField.save() → MEDIA_ROOT/contracts/2026/02/file.pdf
Browser ← GET document_url ← SerializerMethodField ← request.build_absolute_uri(obj.document.url)
```

**Next steps:**
- [x] EPIC 2 Phase 3: Expiration indicator + badge refactor — done in Session 9
- [ ] EPIC 3: Onboarding automation

---

## Session 9 (2026-02-19) - Expiration Indicator + Bug Fixes (EPIC 2 Phase 3)

**Focus**: Computed API fields, 4-state badge logic, PATCH semantics for nullable fields

**What I built:**
- Backend: is_expiring SerializerMethodField — computed field (no migration), 3-condition guard pattern
- Frontend: 4-state badge system (Pianificato/In Scadenza/Attivo/Scaduto) replacing simple 2-state (Attivo/Chiuso)
- Bug fix: end_date clearing in ContractForm edit mode (PATCH needs explicit null, not field omission)
- Bug fix: isort import order in urls.py (unblocked CI pipeline)
- 7 new tests (4 backend + 3 frontend), total 85

**What I learned:**
- SerializerMethodField reuse: is_expiring follows same pattern as document_url — declare, add to fields, write get_ method
- Boundary conditions in computed fields: "expiring" needs BOTH lower bound (not expired) AND upper bound (within 30 days)
- Bug I wrote: `(end_date - today).days <= 30` is True for negative days too! Expired contracts matched as "expiring"
- PATCH semantics (key lesson):
  - Omitting a field in PATCH = "don't touch this column" (like not including a column in UPDATE SET)
  - Sending field: null = "SET column = NULL" — you must be EXPLICIT to nullify
  - In SQL terms: `UPDATE t SET ral=30000` (omit end_date) vs `UPDATE t SET ral=30000, end_date=NULL` (explicit null)
- v-if/v-else-if chain order: works like SQL CASE WHEN — first matching condition wins, order is critical
- String date comparison: "2026-02-19" > "2025-12-31" works because YYYY-MM-DD is lexicographically ordered
- isort groups: stdlib, third-party, local — alphabetical within each group

**Key pattern: 4-state badge logic (CASE WHEN equivalent):**
```
v-if="start_date > today"           → Pianificato (blue)   -- WHEN start_date > GETDATE()
v-else-if="is_expiring"             → In Scadenza (yellow) -- WHEN DATEDIFF(DAY, GETDATE(), end_date) <= 30
v-else-if="!end_date || end > today" → Attivo (green)      -- WHEN end_date IS NULL OR end_date > GETDATE()
v-else                               → Scaduto (gray)      -- ELSE (past end_date)
```

**Key pattern: PATCH null vs omit:**
| Action | Frontend payload | HTTP body | Backend behavior |
|---|---|---|---|
| Don't change end_date | omit field | `{"ral": 30000}` | end_date unchanged |
| Clear end_date | send null | `{"ral": 30000, "end_date": null}` | end_date = NULL |
| Set end_date | send value | `{"ral": 30000, "end_date": "2026-12-31"}` | end_date = value |

**Bug caught by manual testing:**
- Badge showed "Chiuso" instead of "In Scadenza": Docker container hadn't reloaded (hard refresh fixed)
- Clearing end_date in edit mode did nothing: payload used `delete` instead of `= null` for PATCH

**Next steps:**
- [ ] EPIC 3: Onboarding automation
